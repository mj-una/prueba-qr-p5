<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>𝓣𝓾 𝓟𝓻𝓸𝓹𝓲𝓸 𝓠𝓡</title>
	<script src="https://q5js.org/q5.min.js"></script>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
			text-align: center;
			font-family: sans-serif;
		}
		body {
			width: 100dvw;
			height: 100dvh;
			cursor: move;
			background-color: rgb(90, 91, 96);
		}
		main {
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			position: relative;
		}
		#contenedorQ5 {
			width: 100%;
			height: 100%;
			position: absolute;
			top: 0;
			z-index: 2;
		}
		#contenedorQ5 canvas {
			touch-action: none;
			position: absolute;
			top: 0;
		}
		#contenedorQ5 video {
			display: none !important;
		}
		#contenedorInput {
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			position: absolute;
			z-index: 3;
			pointer-events: none;
		}
		#contenedorInput input, #contenedorInput button {
			margin: 0.1rem;
			padding: 1rem;
			pointer-events: auto;
			box-shadow: 0 0 10px 6px rgba(255, 255, 255, 0.182);
		}
		#contenedorInput input {
			background-color: rgb(255, 255, 255);
			cursor: cell;
		}
		#contenedorInput button {
			background-color: rgb(176, 176, 176);
			cursor: pointer;
		}
		#contenedorInput div {
			text-shadow: 0 1px 7px rgb(255, 255, 255);
			position: absolute;
			bottom: 1rem;
			pointer-events: auto;
			cursor: help;
		}
		#contenedorInput div a {
			cursor: pointer;
		}
	</style>
	<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,
	<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 60 60'>
		<style> .cs { stroke: rgb(0, 0, 0); stroke-width: 1; } </style>
		<style> .bl { fill: rgb(255, 255, 255); } </style>
		<style> .ng { fill: rgb(0, 0, 0); } </style>
		<circle cx='30' cy='30' r='30' class='cs ng'/>
		<circle cx='30' cy='30' r='10' class='cs bl'/>
		<circle cx='10' cy='30' r='10' class='cs bl'/>
		<circle cx='50' cy='30' r='10' class='cs bl'/>
		<circle cx='40' cy='12.67' r='10' class='cs bl'/>
		<circle cx='20' cy='12.67' r='10' class='cs bl'/>
		<circle cx='40' cy='47.32' r='10' class='cs bl'/>
		<circle cx='20' cy='47.32' r='10' class='cs bl'/> 
	</svg>"/>
</head>
<body>
	<main>
		<div id="contenedorQ5"></div>
		<div id="contenedorInput">
			<input type="text" id="inputText" placeholder="Ingresa un link">
			<button type="button" id="inputBtn">GENERAR</button>
			<div>
				𝓹𝓸𝓻 𝓗𝓪𝓬𝓱𝓮 𝓣𝓮𝓶𝓮𝓵𝓮<br>
				una interfaz amigable para: <a href="https://qr-code-styling.com/" target="_blank">qr-code-styling.com/</a>
			</div>
		</div>
	</main>
	<div id="hiddenQR" style="display: none"></div>
	<script type="module">

  import QRCodeStyling from "https://cdn.skypack.dev/pin/qr-code-styling@v1.9.2-ky0NCVWkCWGuVcbxT4Lf/mode=imports,min/optimized/qr-code-styling.js";

	// ajustes
	const config = {
		"type": "canvas",
		"shape": "square",
		"width": 540,
		"height": 540,
		"data": "Lorem ipsum dolor, sit amet consectetur adipisicing elit.",
		"margin": 0,
		"qrOptions": {
			"typeNumber": "0",
			"mode": "Byte",
			"errorCorrectionLevel": "Q"
		},
		"imageOptions": {
			"saveAsBlob": true,
			"hideBackgroundDots": true,
			"imageSize": 0.4,
			"margin": 0
		},
		"dotsOptions": {
			"type": "square",
			"color": "#000000",
			"roundSize": true
		},
		"backgroundOptions": {
			"round": 0,
			"color": "#ffffff"
		},
		"image": null,
		"dotsOptionsHelper": {
			"colorType": {
				"single": true,
				"gradient": false
			},
			"gradient": {
				"linear": true,
				"radial": false,
				"color1": "#6a1a4c",
				"color2": "#6a1a4c",
				"rotation": "0"
			}
		},
		"cornersSquareOptions": {
			"type": "square",
			"color": "#000000",
			"gradient": null
		},
		"cornersSquareOptionsHelper": {
			"colorType": {
				"single": true,
				"gradient": false
			},
			"gradient": {
				"linear": true,
				"radial": false,
				"color1": "#000000",
				"color2": "#000000",
				"rotation": "0"
			}
		},
		"cornersDotOptions": {
			"type": "",
			"color": "#000000"
		},
		"cornersDotOptionsHelper": {
			"colorType": {
				"single": true,
				"gradient": false
			},
			"gradient": {
				"linear": true,
				"radial": false,
				"color1": "#000000",
				"color2": "#000000",
				"rotation": "0"
			}
		},
		"backgroundOptionsHelper": {
			"colorType": {
				"single": true,
				"gradient": false
			},
			"gradient": {
				"linear": true,
				"radial": false,
				"color1": "#ffffff",
				"color2": "#ffffff",
				"rotation": "0"
			}
		}
	}

	const contenedor = document.querySelector("#contenedorQ5");
	new Q5("global", contenedor);

  const assets = {};
	let flagIntro = true;

	const reiniciarVideo = video => {
		if (!video) return;
		video.currentTime = 0;
		video.play();
	}

	document.querySelector("#inputBtn").addEventListener("click", () => {
		if (flagIntro) flagIntro = false;
		reiniciarVideo(assets.shrek);
		reiniciarVideo(assets.eva);
		reiniciarVideo(assets.flecha);
		reiniciarVideo(assets.chispa);
		
		// actualiza ajuste
		config.data = document.querySelector("#inputText").value || "lorem ipsum";

		// oculta contenedor input
		document.querySelector("#contenedorInput").style.display = "none";

		// crea el qr segun ajustes
		const qr = new QRCodeStyling(config);
	
		// limpia div oculto
		const hidden = document.getElementById("hiddenQR");
		hidden.innerHTML = "";
		
		// genera un canvas en el div oculto
		qr.append(hidden);
		
		// exporta imagen png a blob
		qr.getRawData("png").then(blob => {
			assets.qrBlob = blob; // guarda blob en memoria
			const url = URL.createObjectURL(blob);
			loadImage(url, img => assets.qrImg = img); // carga imagen en q5
			setTimeout(() => URL.revokeObjectURL(url), 2000); // y libera url
		}).catch(err => {
			console.warn("Error generando blob del QR:", err);
		});
	})

	const RESOLU = 400;

  window.preload = () => {
		assets.wordart = loadImage("wordart.png", img => img.resize(800, 220));
		assets.stars = createVideo("stars.webm");
		assets.stars.muted = true;
		assets.stars.loop = true;
		assets.stars.play();
	}

  window.setup = () => {
    createCanvas(10, 10);
		pixelDensity(1);
		handleResize();
		displayMode(MAXED);
		mouseX = Infinity;
		background(255);
		noStroke();
		textFont("serif");
		textSize(15);

		assets.piolin = loadImage("piolin.png", img => img.resize(100, 120));

		assets.shrek = createVideo("shrek.mp4");
		assets.shrek.muted = true;
		assets.shrek.loop = true;
		assets.shrek.pause();

		assets.eva = createVideo("evangelion.mp4");
		assets.eva.muted = true;
		assets.eva.loop = true;
		assets.eva.pause();

		assets.flecha = createVideo("flecha.mp4");
		assets.flecha.muted = true;
		assets.flecha.loop = true;
		assets.flecha.pause();

		assets.chispa = createVideo("chispa.webm");
		assets.chispa.muted = true;
		assets.chispa.loop = true;
		assets.chispa.pause();
  }

  window.draw = () => {
		cursor("move");
		const mod255 = frameCount % 255;
		
		// PORTADA
		if (flagIntro) {
			const modToque = mouseIsPressed
				? (toque.iniT + dist(toque.iniX, toque.iniY, mouseX, mouseY)) % 255
				: mod255;

			background(modToque, 100, 400 - modToque, 10);

			// estrellas
			pushMatrix();
			translate(width, height);
			rotate(PI);
			for (let i = 0; i < width + 250; i += 250) {
				image(assets.stars, i, 0, 250, max(height * 0.6, 400));
			}
			popMatrix();

			// titulo
			image(assets.wordart, halfWidth - 200, height - max(height * 0.7, 370));

			// resplandor circular
			push();
			fill(200, 1);
			shadow(200, 20);
			shadowBox(0, 0, 15);
			for (let i = 6; i > 0; i--) {
				circle(halfWidth, halfHeight, i * modToque);
			}
			pop();
			return;
		}

		// NO PORTADA
		textAlign(CENTER);
		background(mod255, 100, 400 - mod255, 10);
		const { qrImg, shrek, eva, piolin } = assets;

		// particulas
		push();
		fill(255, 100);
		shadow(255, 100);
		shadowBox(0, 0, 10);
		for (let i = 0; i < 130; i++) {
			const ns = noise(i * width, frameCount * 0.001 + i * 100, mouseX * 0.001);
			const cx = (ns * width * 2) % width;
			const cy = (i * mod255 * 0.1) % height;
			circle(cx, cy, 5);
		}
		pop();

		// resplandor rectangular
		push();
		fill(200, 1);
		shadow(200, 255, 210);
		shadowBox(0, 0, mod255);
		stroke(255);
    rect(halfWidth - 151, halfHeight - 151, 302, 302);
		shadowBox(0, 0, (frameCount + 127) % 255);
    rect(halfWidth - 151, halfHeight - 151, 302, 302);
		pop();
    if (qrImg) image(qrImg, halfWidth - 150, halfHeight - 150, 300, 300);

		// aviso listo
		const sx = mouseX - 55;
		push();
		fill(140, 170, 150);
		stroke(30, 255, 100);
		shadow(30, 255, 100, 30);
		shadowBox(0, 0, 6);
		rect(sx, mouseY, 120, 100);
		if (shrek) image(shrek, sx, mouseY, 120, 100);
		fill(30, 255, 100);
		shadow(255);
		shadowBox(0, 0, 5);
		textSize(30);
		text("Listo!!!", sx + 64, mouseY + 86);
		pop();

		// boton volver
		const ex = width * 0.01;
		const ey = height * 0.04;
		push();
		noStroke();
		fill(60, 80, 200);
		rect(ex, ey, 100, 100);
		if (eva) image(eva, ex, ey, 100, 100);
		const eCol = inFill(mouseX, mouseY);
		stroke(255);
		shadow(255);
		shadowBox(0, 0, eCol ? 6 : 1);
		textSize(30);
		textFont("serif")
		text("Volver", ex + 50, ey + 80);
		push();
		noFill();
		rect(ex, ey, 100, 100);
		pop();
		if (eCol) {
			rect(sx, mouseY, 120, 100);
			textSize(36);
			textFont("sans-serif")
			text("otro\nqr??", sx + 54, mouseY + 40);
			fill(255, 50);
			stroke(255, 50);
			shadow(255);
			shadowBox(0, 0, random(10, 30));
			for (let i = 0; i < 10; i++) {
				circle(mouseX, mouseY, random(4, 12));
			}
			cursor(HAND);
		}
		pop();

		// boton descargar
		const px = width * 0.96 - (piolin?.width ?? 100);
		const py = height * 0.96 - (piolin?.height ?? 120);
		push();
		fill(200, 180, 240);
		rect(px, py, 100, 120);
		if (piolin) image(piolin, px, py, 100, 120);
		noFill();
		stroke(255);
		shadowBox(0, 0, 2);
		shadow(255);
		rect(px, py, 100, 120);
		const pCol = inFill(mouseX, mouseY);
		pCol ? shadow(225, 60, 80) : noShadow();
		fill(225, 60, 80);
		stroke(225, 60, 80);
		text("DESCARGAR", px + 50, py + 20);
		if (pCol) {
			push();
			fill(225);
			stroke(225);
			textSize(28);
			textFont("sans-serif");
			cursor(HAND);
			text("qr.png", px + 50, py + 110);
			if (assets.flecha) image(assets.flecha, px + 18, py + 30, 60, 60);
			if (assets.chispa) image(assets.chispa, mouseX - 50, mouseY - 70, 100, 120);
			pop();
		}
		pop();
  }

	let toque = {};
	let flagV = false;
	let flagD = false;
	window.mousePressed = () => {
		if (flagIntro) {
			toque.iniT = frameCount % 255;
			toque.iniX = mouseX;
			toque.iniY = mouseY;
			return;
		}

		const { piolin = {} } = assets;

		if (
			mouseX > width * 0.01 &&
			mouseX < width * 0.01 + 100 &&
			mouseY > height * 0.04 &&
			mouseY < height * 0.04 + 100
		) flagV = true;
		
		else if (
			mouseX > width * 0.96 - piolin.width &&
			mouseX < width * 0.96 - piolin.width + 100 &&
			mouseY > height * 0.96 - piolin.height &&
			mouseY < height * 0.96 - piolin.height + 120
		) flagD = true;
	}

	window.mouseReleased = () => {
		if (flagIntro) {
			toque = {};
			flagV = false;
			flagD = false;
			return;
		}

		const { piolin = {} } = assets;

		if (
			flagV &&
			mouseX > width * 0.01 &&
			mouseX < width * 0.01 + 100 &&
			mouseY > height * 0.04 &&
			mouseY < height * 0.04 + 100
		) {
			flagV = false;
			flagD = false;
			flagIntro = true;
			document.querySelector("#inputText").value = "";
			document.querySelector("#contenedorInput").style.display = "flex";
		}
		
		else if (
			flagD &&
			mouseX > width * 0.96 - piolin.width &&
			mouseX < width * 0.96 - piolin.width + 100 &&
			mouseY > height * 0.96 - piolin.height &&
			mouseY < height * 0.96 - piolin.height + 120
		) {
			flagD = false;
			if (assets.qrBlob) downloadBlob(assets.qrBlob);
			console.warn("Error descargando blob del QR");
		}
	}

	function downloadBlob(blob) {
		if (!blob) {
			console.warn("Error interno. bla bla");
			return;
	}
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = "qr.png";
		document.body.appendChild(a);
		a.click();
		a.remove();
		setTimeout(() => URL.revokeObjectURL(url), 1500);
	}

	function handleResize() {
		requestAnimationFrame(() => {
			const vw = window.visualViewport?.width ?? window.innerWidth;
			const vh = window.visualViewport?.height ?? window.innerHeight;
			const prp = vw / vh;
			const isVert = prp < 1;
			const maxSize = isVert
				? RESOLU * vh / vw
				: RESOLU * prp;

			isVert
				? resizeCanvas(RESOLU, maxSize)
				: resizeCanvas(maxSize, RESOLU);
			background(255);
		});
	}

	window.addEventListener("resize", handleResize);

	</script>
</body>
</html>
